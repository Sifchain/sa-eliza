Architecture


Eliza Agent OS is a comprehensive, modular, and highly extensible system that brings together a variety of components to create intelligent, autonomous agents capable of interacting with users across multiple platforms. At its core, the architecture is built around three fundamental pillars:

1. The Agent Core
   • The "@agent" package is the heart of the system. It boots up the intelligent agent by loading and merging configuration files (in JSON format) that define a character's personality, voice settings, and available functionalities.

   • It sets up essential connections to support systems such as databases (Postgres, SQLite, Supabase, MongoDB, etc.) and caching layers (Redis or local caches), ensuring that all stateful data—like conversation histories or persistent memories—is reliably stored and retrieved.

   • Agents encapsulate the decision-making logic. They parse incoming messages, decide whether or not to act based on pre-defined templates and rules, and invoke corresponding action handlers. This core logic is agnostic to the communication channel, allowing the system to be robust and adaptable.

2. Plugins
   • Plugins extend the capabilities of the agent far beyond simple messaging. For example, the "@plugin-github" plugin introduces deep GitHub-specific functionality into the system.
     - It starts by defining its package metadata (through package.json) and ensuring proper dependency management with libraries like @octokit/rest.
     - Rigorous input validation is achieved through constants and types defined using libraries like Zod, ensuring that every GitHub action—from creating issues and commits to initializing repositories—receives correctly formatted data.
     - The plugin is structured around modular "actions" (each with unique names, descriptions, validate functions, and handler logic) and "providers" to interact with various GitHub contents like source code and documentation.
     - Finally, its components are re-exported in a unified interface, so that the core agent can seamlessly integrate these functionalities.
   • Similarly, other plugins (such as @plugin-email and others) offer specialized integrations that address distinct needs within the ecosystem, making it easy to customize and extend the functionality without altering the system's core.

3. Clients
   • Clients function as the "bridges" between the core agent and the external communication platforms. They abstract away platform-specific details, allowing agents to interact with the outside world effortlessly.
   • For example, the Slack client (@client-slack) handles all aspects of connection management, event listening (via a dedicated event adapter), and message formatting. It captures events like new messages, URL verifications, and reactions, then forwards these events to the agent's logic.
   • This separation enables the agents to generate responses and take actions without needing to know the specifics of how Slack, Twitter, Discord, or any other platform operates. It also means that integrating a new communication channel is as simple as swapping out or adding a new client module.

4. Adapters
   • Adapters serve as abstraction layers for data persistence and caching. They enable the system to interact with different databases and storage systems using a unified API.
   • For instance, the "@adapter-postgres" module integrates PostgreSQL into the ecosystem. It manages schema migrations, seed data, and leverages advanced features such as pgvector for vector-based similarity search and fuzzystrmatch for text matching.
   • The adapter is designed with careful separation of concerns: SQL migration scripts establish the database schema and row-level security measures, dedicated utility functions handle dynamic SQL queries, and rigorous testing (often in Docker-based environments) confirms the correct operation of critical functions.
   • By encapsulating all the complexities of database operations, adapters allow other components (agents, plugins, and clients) to store and retrieve data efficiently without needing to manage the underlying database intricacies.